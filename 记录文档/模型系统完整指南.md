# 模型系统完整指南

## 目录
1. [模型加载方式和布局情况](#1-模型加载方式和布局情况)
2. [模型反光实现方法](#2-模型反光实现方法)
3. [光源大小和高度等的调节方法](#3-光源大小和高度等的调节方法)
4. [模型大小、高度、朝向等的调整方法](#4-模型大小高度朝向等的调整方法)
5. [清晰度的优化和调整方法](#5-清晰度的优化和调整方法)

---

## 1. 模型加载方式和布局情况

### 1.1 模型加载系统

项目使用 **Assimp** (Open Asset Import Library) 加载3D模型，支持多种格式：
- GLTF/GLB (推荐格式，完整支持PBR材质)
- FBX (Autodesk格式)
- OBJ (简单模型)
- 其他Assimp支持的格式

### 1.2 加载流程

```cpp
// main.cpp 中的加载代码
Model island("assets/model/book/source/TEST2.fbx");
```

**加载步骤：**
1. Assimp导入器读取文件
2. 处理场景节点树（递归）
3. 提取网格数据（顶点、法线、纹理坐标）
4. 加载材质和纹理
5. 创建OpenGL缓冲对象（VBO、VAO、EBO）

### 1.3 纹理查找策略

`Model.h` 中的 `TextureFromFile` 函数实现了智能纹理查找：

```cpp
std::vector<std::string> possiblePaths = {
    directory + "/" + bareFilename,           // 模型同目录
    parentDir + "/textures/" + bareFilename,  // textures子文件夹
    parentDir + "/" + bareFilename,           // 父目录
    filename                                   // 绝对路径
};
```

**推荐目录结构：**
```
assets/model/book/
├── source/
│   └── TEST2.fbx
└── textures/
    ├── diffuse.png
    └── specular.png
```

### 1.4 场景布局

当前场景包含三个主要元素：

```
Y轴 (垂直)
↑
│   [Skybox] - 天空盒（无限远）
│
│   Y = 4.5  [Camera] - 摄像机初始位置
│   Y = 3-5  [Lights] - 4个场景光源
│   Y = 0.3  [Model] - 书本模型（平放）
│   Y = 0.0  [Ground] - 地面平面
```

**坐标系统：**
- X轴：左(-) → 右(+)
- Y轴：下(-) → 上(+)
- Z轴：前(-) → 后(+)

---

## 2. 模型反光实现方法

### 2.1 Blinn-Phong 光照模型

项目使用 **Blinn-Phong** 着色模型，包含三个分量：

1. **环境光 (Ambient)**: 基础照明，模拟环境反射
2. **漫反射 (Diffuse)**: 依赖光源方向和表面法线
3. **镜面反射 (Specular)**: 高光效果，依赖视角

### 2.2 Shader 实现

**Fragment Shader (`model.fs`) 核心代码：**

```glsl
// 材质属性
uniform float materialShininess = 64.0;  // 光泽度 (32-128)
uniform float specularStrength = 0.5;    // 高光强度 (0.0-1.0)

// Blinn-Phong 计算
vec3 CalcPointLight(...) {
    // 1. 计算光源方向
    vec3 lightDir = normalize(lightPos - fragPos);
    
    // 2. 漫反射 (Lambertian)
    float diff = max(dot(normal, lightDir), 0.0);
    
    // 3. 镜面反射 (Blinn-Phong)
    vec3 halfwayDir = normalize(lightDir + viewDir);
    float spec = pow(max(dot(normal, halfwayDir), 0.0), materialShininess);
    
    // 4. 光衰减 (距离平方反比)
    float distance = length(lightPos - fragPos);
    float attenuation = intensity / (1.0 + 0.09 * distance + 0.032 * distance * distance);
    
    // 5. 组合结果
    vec3 ambient = 0.02 * lightColor;
    vec3 diffuse = diff * lightColor * 0.8;
    vec3 specular = spec * lightColor * specularStrength;
    
    return (ambient + diffuse + specular) * attenuation * baseColor;
}
```

### 2.3 参数调整指南

**在 `main.cpp` 中设置材质属性：**

```cpp
// 模型材质
modelShader.setFloat("materialShininess", 64.0f);   // 光泽度
modelShader.setFloat("specularStrength", 0.5f);     // 高光强度

// 地面材质（较低反光）
groundShader.setFloat("groundShininess", 32.0f);
groundShader.setFloat("groundSpecularStrength", 0.3f);
```

**参数效果对照表：**

| 参数 | 低值 | 中值 | 高值 | 效果 |
|------|------|------|------|------|
| **Shininess** | 16 | 64 | 256 | 光斑大小（低=大而柔和，高=小而锐利）|
| **SpecularStrength** | 0.0 | 0.5 | 1.0 | 高光强度（0=无反光，1=镜面）|

**材质预设：**
```cpp
// 金属材质（强反光）
materialShininess = 128.0f;
specularStrength = 0.8f;

// 纸张/布料（弱反光）
materialShininess = 32.0f;
specularStrength = 0.2f;

// 塑料（中等反光）
materialShininess = 64.0f;
specularStrength = 0.5f;

// 水面（镜面反射）
materialShininess = 256.0f;
specularStrength = 1.0f;
```

### 2.4 烟花爆炸闪光效果

**准备工作已完成：**
1. ? 支持最多16个动态点光源
2. ? 临时光源系统（自动衰减和移除）
3. ? 增强的镜面反射

**实现烟花闪光（示例）：**
```cpp
// 烟花爆炸时添加临时光源
lightManager.AddTemporaryLight(
    explosionPosition,              // 爆炸位置
    glm::vec3(1.0f, 0.5f, 0.2f),   // 橙红色
    15.0f,                          // 高强度（会产生强烈反光）
    2.0f                            // 持续2秒
);
```

**测试命令（已在代码中）：**
- 按 **T** 键：在摄像机位置添加测试光源（持续5秒）

---

## 3. 光源大小和高度等的调节方法

### 3.1 点光源管理系统

项目使用 `PointLightManager` 管理所有光源（`include/PointLight.h`）：

```cpp
struct PointLight {
    glm::vec3 position;    // 位置
    glm::vec3 color;       // 颜色 (RGB, 0.0-1.0)
    float intensity;       // 强度
    float lifetime;        // 生命周期（-1表示永久）
    bool isPermanent;      // 是否永久光源
};
```

### 3.2 场景光源配置

**当前配置（`main.cpp` 中）：**

```cpp
// 光源1：前左 - 暖白色
lightManager.AddPermanentLight(
    glm::vec3(-3.0f, 3.0f, 3.0f),   // 位置 (X, Y, Z)
    glm::vec3(1.0f, 0.95f, 0.9f),   // 颜色 (暖白)
    3.0f                             // 强度
);

// 光源2：前右 - 冷白色
lightManager.AddPermanentLight(
    glm::vec3(3.0f, 3.0f, 3.0f),
    glm::vec3(0.9f, 0.95f, 1.0f),   // 颜色 (冷白)
    3.0f
);

// 光源3：后中 - 纯白色
lightManager.AddPermanentLight(
    glm::vec3(0.0f, 4.0f, -3.0f),
    glm::vec3(1.0f, 1.0f, 1.0f),    // 颜色 (纯白)
    3.0f
);

// 光源4：顶部 - 淡蓝色
lightManager.AddPermanentLight(
    glm::vec3(0.0f, 5.0f, 0.0f),
    glm::vec3(0.95f, 0.95f, 1.0f),  // 颜色 (淡蓝)
    3.0f
);
```

### 3.3 调整指南

#### 3.3.1 位置调整

```cpp
// 基本语法
glm::vec3(X, Y, Z)

// 示例：调整高度
glm::vec3(0.0f, 2.0f, 0.0f)   // 低位光源（台灯效果）
glm::vec3(0.0f, 5.0f, 0.0f)   // 中位光源（室内照明）
glm::vec3(0.0f, 10.0f, 0.0f)  // 高位光源（天光效果）

// 示例：调整水平距离
glm::vec3(5.0f, 3.0f, 5.0f)   // 远距离（柔和照明）
glm::vec3(2.0f, 3.0f, 2.0f)   // 近距离（强烈照明）
```

**可视化光源布局：**
```
         顶视图 (Y轴向上)
         
    前 (Z+)
      ↑
      │
光2 ●─┼─● 光1   Y = 3-5
   u  │  v
  u   ●   v      ← 书本中心 (0, 0.3, 0)
 u   模型  v
← ─────●───── → X轴
          光3
            ↓
          后 (Z-)
```

#### 3.3.2 强度调整

**光衰减公式（在shader中）：**
```glsl
attenuation = intensity / (1.0 + 0.09 * distance + 0.032 * distance^2)
```

**强度效果对照表：**

| 强度值 | 适用场景 | 视觉效果 |
|--------|----------|----------|
| 0.5-1.0 | 微弱环境光 | 月光、星光 |
| 2.0-4.0 | 正常室内照明 | 台灯、吊灯 |
| 5.0-10.0 | 强照明 | 聚光灯、路灯 |
| 15.0+ | 爆炸/特效 | 烟花爆炸、闪电 |

**调整示例：**
```cpp
// 柔和场景照明
lightManager.AddPermanentLight(pos, color, 2.0f);

// 强聚光灯效果
lightManager.AddPermanentLight(pos, color, 8.0f);

// 烟花爆炸（临时光源）
lightManager.AddTemporaryLight(pos, color, 20.0f, 1.5f);
```

#### 3.3.3 颜色调整

```cpp
// RGB颜色系统（范围 0.0-1.0）

// 常用颜色预设
glm::vec3(1.0f, 1.0f, 1.0f)     // 纯白色
glm::vec3(1.0f, 0.95f, 0.9f)    // 暖白色（日光）
glm::vec3(0.9f, 0.95f, 1.0f)    // 冷白色（荧光）
glm::vec3(1.0f, 0.8f, 0.6f)     // 黄色（白炽灯）
glm::vec3(1.0f, 0.5f, 0.2f)     // 橙色（火光）
glm::vec3(1.0f, 0.3f, 0.3f)     // 红色（烟花）
glm::vec3(0.3f, 0.5f, 1.0f)     // 蓝色（冷光）
glm::vec3(0.5f, 1.0f, 0.5f)     // 绿色（霓虹）
```

### 3.4 光衰减系数调整

**在 shader 中修改（高级用户）：**

```glsl
// model.fs 和 ground.fs 中的衰减计算
float attenuation = intensity / (1.0 + K1 * distance + K2 * distance^2);

// 默认值：
// K1 = 0.09  (线性衰减)
// K2 = 0.032 (二次衰减)

// 调整效果：
// K1 更大 → 近距离衰减快，远距离暗
// K2 更大 → 距离影响更显著
// K1 = 0, K2 = 0 → 无衰减（不真实）
```

**推荐衰减参数：**
```glsl
// 小场景（室内）
K1 = 0.14, K2 = 0.07

// 中等场景（当前设置）
K1 = 0.09, K2 = 0.032

// 大场景（室外）
K1 = 0.045, K2 = 0.0075
```

---

## 4. 模型大小、高度、朝向等的调整方法

### 4.1 变换矩阵系统

OpenGL 使用4x4变换矩阵进行模型变换：

```
最终位置 = 投影矩阵 × 视图矩阵 × 模型矩阵 × 顶点位置
```

**在 `main.cpp` 中的模型变换代码：**

```cpp
glm::mat4 modelMatrix = glm::mat4(1.0f);  // 单位矩阵

// 1. 平移（位置）
modelMatrix = glm::translate(modelMatrix, glm::vec3(X, Y, Z));

// 2. 旋转（朝向）
modelMatrix = glm::rotate(modelMatrix, glm::radians(角度), glm::vec3(轴X, 轴Y, 轴Z));

// 3. 缩放（大小）
modelMatrix = glm::scale(modelMatrix, glm::vec3(缩放X, 缩放Y, 缩放Z));
```

### 4.2 位置调整（Y轴高度）

**当前设置：**
```cpp
modelMatrix = glm::translate(modelMatrix, glm::vec3(0.0f, 0.3f, 0.0f));
```

**调整指南：**

| Y值 | 效果 | 适用场景 |
|-----|------|----------|
| 0.0 | 地面水平 | 与地面齐平（可能穿模）|
| 0.1 | 略微抬起 | 防止Z-fighting |
| 0.3 | 清晰分离 | **当前推荐值** |
| 0.5+ | 悬浮效果 | 飞行物体 |
| 1.0+ | 高悬浮 | 特殊效果 |

**示例：**
```cpp
// 放在地面上（贴地）
glm::translate(modelMatrix, glm::vec3(0.0f, 0.05f, 0.0f));

// 当前设置（稍抬起）
glm::translate(modelMatrix, glm::vec3(0.0f, 0.3f, 0.0f));

// 移动到场景中心上方
glm::translate(modelMatrix, glm::vec3(0.0f, 2.0f, 0.0f));

// 偏移到左侧
glm::translate(modelMatrix, glm::vec3(-2.0f, 0.3f, 0.0f));
```

### 4.3 旋转调整（朝向）

**当前设置（书本平放）：**
```cpp
// 绕X轴旋转-90度，使书本平放
modelMatrix = glm::rotate(modelMatrix, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.0f));
```

**旋转轴说明：**
- `glm::vec3(1, 0, 0)` → 绕X轴旋转（俯仰）
- `glm::vec3(0, 1, 0)` → 绕Y轴旋转（偏航，左右转）
- `glm::vec3(0, 0, 1)` → 绕Z轴旋转（滚转）

**示例：**
```cpp
// 书本完全平放（当前）
glm::rotate(modelMatrix, glm::radians(-90.0f), glm::vec3(1, 0, 0));

// 书本竖立（垂直）
glm::rotate(modelMatrix, glm::radians(0.0f), glm::vec3(1, 0, 0));

// 书本斜放（45度）
glm::rotate(modelMatrix, glm::radians(-45.0f), glm::vec3(1, 0, 0));

// 书本旋转朝向左侧
glm::rotate(modelMatrix, glm::radians(90.0f), glm::vec3(0, 1, 0));

// 组合旋转：平放 + 旋转180度
glm::rotate(modelMatrix, glm::radians(-90.0f), glm::vec3(1, 0, 0));
glm::rotate(modelMatrix, glm::radians(180.0f), glm::vec3(0, 1, 0));
```

**旋转顺序很重要！**
```cpp
// 顺序1：先旋转Y轴，再旋转X轴
glm::rotate(..., Y轴);
glm::rotate(..., X轴);

// 顺序2：先旋转X轴，再旋转Y轴（结果不同！）
glm::rotate(..., X轴);
glm::rotate(..., Y轴);
```

### 4.4 缩放调整（大小）

**当前设置：**
```cpp
modelMatrix = glm::scale(modelMatrix, glm::vec3(0.25f, 0.25f, 0.25f));
```

**调整指南：**

| 缩放值 | 效果 | 适用场景 |
|--------|------|----------|
| 0.1 | 10%原始大小 | 微型模型 |
| 0.25 | 25%原始大小 | **当前设置（书本）** |
| 0.5 | 50%原始大小 | 中型物体 |
| 1.0 | 100%原始大小 | 原始尺寸 |
| 2.0+ | 放大 | 巨型物体 |

**示例：**
```cpp
// 统一缩放（保持比例）
glm::scale(modelMatrix, glm::vec3(0.5f, 0.5f, 0.5f));

// 非均匀缩放（改变比例）
glm::scale(modelMatrix, glm::vec3(1.0f, 0.5f, 1.0f));  // 压扁（高度减半）
glm::scale(modelMatrix, glm::vec3(0.5f, 2.0f, 0.5f));  // 拉长（高度翻倍）

// 镜像翻转（负值）
glm::scale(modelMatrix, glm::vec3(-1.0f, 1.0f, 1.0f));  // X轴镜像
```

### 4.5 完整变换示例

**示例1：书本平放在桌面**
```cpp
glm::mat4 modelMatrix = glm::mat4(1.0f);
modelMatrix = glm::translate(modelMatrix, glm::vec3(0.0f, 1.0f, 0.0f));  // 桌面高度
modelMatrix = glm::rotate(modelMatrix, glm::radians(-90.0f), glm::vec3(1, 0, 0));
modelMatrix = glm::scale(modelMatrix, glm::vec3(0.3f, 0.3f, 0.3f));
```

**示例2：书本竖立在书架**
```cpp
glm::mat4 modelMatrix = glm::mat4(1.0f);
modelMatrix = glm::translate(modelMatrix, glm::vec3(-2.0f, 0.5f, -3.0f));
modelMatrix = glm::rotate(modelMatrix, glm::radians(0.0f), glm::vec3(1, 0, 0));  // 不旋转，保持垂直
modelMatrix = glm::scale(modelMatrix, glm::vec3(0.2f, 0.2f, 0.2f));
```

**示例3：飞行的书本（动画）**
```cpp
float time = glfwGetTime();
glm::mat4 modelMatrix = glm::mat4(1.0f);
modelMatrix = glm::translate(modelMatrix, glm::vec3(0.0f, 2.0f + sin(time), 0.0f));  // 上下浮动
modelMatrix = glm::rotate(modelMatrix, (float)time, glm::vec3(0, 1, 0));  // 旋转
modelMatrix = glm::scale(modelMatrix, glm::vec3(0.25f, 0.25f, 0.25f));
```

### 4.6 调试技巧

**1. 使用控制台输出检查位置：**
```cpp
std::cout << "Model position: " << modelMatrix[3][0] << ", " 
          << modelMatrix[3][1] << ", " << modelMatrix[3][2] << std::endl;
```

**2. 可视化边界框（可选添加）：**
```cpp
// 在Model类中添加
void DrawBoundingBox() {
    // 绘制模型的轴对齐包围盒
}
```

**3. 使用摄像机控制查看：**
- 按 **M** 锁定鼠标，旋转视角
- 按 **WASD** 移动摄像机
- 按 **Space/Shift** 上下移动
- 按 **F** 聚焦到模型中心

---

## 5. 清晰度的优化和调整方法

### 5.1 纹理采样优化

#### 5.1.1 Mipmap 设置

**在 `Model.h` 的 `TextureFromFile` 函数中：**

```cpp
// 生成 Mipmap（多级渐远纹理）
glGenerateMipmap(GL_TEXTURE_2D);

// 设置过滤模式
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);  // 三线性过滤
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);                 // 双线性过滤

// 调整 LOD 偏移（控制清晰度）
glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_LOD_BIAS, -0.5f);  // 负值=更清晰，正值=更柔和
```

#### 5.1.2 纹理过滤模式对比

| 模式 | 性能 | 质量 | 适用场景 |
|------|------|------|----------|
| `GL_NEAREST` | 最快 | 像素化 | 像素艺术 |
| `GL_LINEAR` | 快 | 模糊 | 远景 |
| `GL_LINEAR_MIPMAP_NEAREST` | 中 | 中等 | 一般场景 |
| `GL_LINEAR_MIPMAP_LINEAR` | 慢 | **最佳** | **推荐（当前）** |

**调整示例：**
```cpp
// 最清晰（但可能出现摩尔纹）
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_LOD_BIAS, -1.0f);

// 平衡（当前设置）
glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_LOD_BIAS, -0.5f);

// 柔和（减少闪烁）
glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_LOD_BIAS, 0.0f);
```

### 5.2 各向异性过滤（高级）

**在 `TextureFromFile` 函数中添加：**

```cpp
// 启用各向异性过滤（需要OpenGL扩展）
if (GLAD_GL_EXT_texture_filter_anisotropic) {
    float maxAnisotropy;
    glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &maxAnisotropy);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, maxAnisotropy);
}
```

**效果：** 显著提升斜视角纹理清晰度

### 5.3 抗锯齿设置

#### 5.3.1 MSAA（多重采样抗锯齿）

**在 `main.cpp` 的 GLFW 初始化中添加：**

```cpp
glfwWindowHint(GLFW_SAMPLES, 4);  // 4x MSAA
```

**在 OpenGL 初始化后启用：**
```cpp
glEnable(GL_MULTISAMPLE);
```

**MSAA 级别对比：**
- `GLFW_SAMPLES, 0` - 无抗锯齿（锯齿明显）
- `GLFW_SAMPLES, 2` - 2x MSAA（基础抗锯齿）
- `GLFW_SAMPLES, 4` - 4x MSAA（**推荐**）
- `GLFW_SAMPLES, 8` - 8x MSAA（高质量，性能开销大）

#### 5.3.2 后处理抗锯齿（FXAA/SMAA）

**需要额外实现，步骤：**
1. 渲染到帧缓冲
2. 应用后处理着色器
3. 渲染到屏幕

### 5.4 模型细节优化

#### 5.4.1 法线平滑

**在 Assimp 加载时：**
```cpp
// model.h 中的 loadModel 函数
const aiScene* scene = importer.ReadFile(path, 
    aiProcess_Triangulate |           // 三角化
    aiProcess_GenSmoothNormals |      // 生成平滑法线 ?
    aiProcess_FlipUVs |               // 翻转UV
    aiProcess_CalcTangentSpace        // 计算切线空间
);
```

**效果：** 使模型表面更光滑

#### 5.4.2 法线贴图（未实现，可添加）

**在 shader 中添加法线贴图支持：**

```glsl
// model.fs 中添加
uniform sampler2D texture_normal1;
uniform bool hasNormalMap;

void main() {
    vec3 normal;
    if (hasNormalMap) {
        // 从法线贴图采样
        normal = texture(texture_normal1, TexCoords).rgb;
        normal = normalize(normal * 2.0 - 1.0);  // [-1, 1]
        // 转换到世界空间（需要TBN矩阵）
    } else {
        normal = normalize(Normal);
    }
    // ...
}
```

### 5.5 视口和投影优化

#### 5.5.1 近远裁剪面

**在 `main.cpp` 中：**
```cpp
glm::mat4 projection = glm::perspective(
    glm::radians(camera.Zoom),  // FOV
    (float)SCR_WIDTH / (float)SCR_HEIGHT,  // 宽高比
    0.1f,   // 近裁剪面（太小会导致深度精度问题）
    200.0f  // 远裁剪面
);
```

**调整指南：**
```cpp
// 小场景（室内）
near = 0.1f, far = 50.0f

// 中场景（当前）
near = 0.1f, far = 200.0f

// 大场景（室外）
near = 0.5f, far = 1000.0f
```

**注意：** near/far 比值越大，深度缓冲精度越低

#### 5.5.2 视野角度（FOV）

```cpp
// 在 Camera.h 中调整 ZOOM 常量
const float ZOOM = 45.0f;  // 标准FOV

// 效果对比：
// 30.0f - 望远镜视角（窄）
// 45.0f - 正常视角（推荐）
// 60.0f - 广角视角（宽）
// 90.0f - 超广角（变形明显）
```

### 5.6 颜色空间和Gamma校正

#### 5.6.1 sRGB纹理

**在纹理加载时启用：**
```cpp
// Model.h 中
GLenum internalFormat = (nrComponents == 3) ? GL_SRGB : GL_SRGB_ALPHA;
glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, width, height, 0, format, GL_UNSIGNED_BYTE, data);
```

#### 5.6.2 Gamma校正

**在 shader 输出时应用：**
```glsl
// model.fs 最后
vec3 gammaCorrection(vec3 color) {
    return pow(color, vec3(1.0/2.2));  // 2.2是标准gamma值
}

FragColor = vec4(gammaCorrection(result), 1.0);
```

### 5.7 性能与质量平衡

#### 5.7.1 渲染统计

**添加FPS计数器（在 `main.cpp` 中）：**

```cpp
float lastFPSTime = 0.0f;
int frameCount = 0;

// 在渲染循环中
frameCount++;
if (currentFrame - lastFPSTime >= 1.0f) {
    std::cout << "FPS: " << frameCount << std::endl;
    frameCount = 0;
    lastFPSTime = currentFrame;
}
```

#### 5.7.2 优化建议

**根据FPS调整质量：**

| FPS | 问题 | 解决方案 |
|-----|------|----------|
| < 30 | 性能不足 | 降低MSAA、减少光源、简化模型 |
| 30-60 | 可接受 | 当前设置合适 |
| > 60 | 性能过剩 | 可提高质量设置 |

### 5.8 屏幕分辨率优化

**在 `main.cpp` 中：**
```cpp
// 当前分辨率
const unsigned int SCR_WIDTH = 1280;
const unsigned int SCR_HEIGHT = 720;

// 常用分辨率：
// 1920x1080 - Full HD（推荐）
// 2560x1440 - 2K
// 3840x2160 - 4K（需要强大硬件）
```

**动态分辨率缩放（高级）：**
```cpp
// 以较低分辨率渲染，然后放大到窗口大小
const float renderScale = 0.75f;  // 75%渲染分辨率
const unsigned int renderWidth = SCR_WIDTH * renderScale;
const unsigned int renderHeight = SCR_HEIGHT * renderScale;
```

### 5.9 快速诊断清单

**遇到模糊/不清晰问题时，按顺序检查：**

1. ? **纹理是否加载成功？**
   ```cpp
   std::cout << "Total textures loaded: " << textures_loaded.size() << std::endl;
   ```

2. ? **纹理分辨率是否足够？**
   - 最低：512x512
   - 推荐：1024x1024 或更高

3. ? **LOD偏移是否合适？**
   ```cpp
   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_LOD_BIAS, -0.5f);  // 调整此值
   ```

4. ? **模型缩放是否过大？**
   ```cpp
   // 缩放过大会导致纹理拉伸
   glm::scale(modelMatrix, glm::vec3(0.25f, 0.25f, 0.25f));
   ```

5. ? **摄像机距离是否合适？**
   ```cpp
   Camera camera(glm::vec3(0.0f, 4.5f, 10.0f));  // 调整Z值
   ```

6. ? **MSAA是否启用？**
   ```cpp
   glfwWindowHint(GLFW_SAMPLES, 4);
   glEnable(GL_MULTISAMPLE);
   ```

---

## 附录：完整配置示例

### A.1 高质量配置

```cpp
// main.cpp 配置
const unsigned int SCR_WIDTH = 1920;
const unsigned int SCR_HEIGHT = 1080;

// GLFW初始化
glfwWindowHint(GLFW_SAMPLES, 8);  // 8x MSAA

// 模型变换
modelMatrix = glm::translate(modelMatrix, glm::vec3(0.0f, 0.3f, 0.0f));
modelMatrix = glm::scale(modelMatrix, glm::vec3(0.5f, 0.5f, 0.5f));  // 更大模型

// 材质属性
modelShader.setFloat("materialShininess", 128.0f);  // 高光泽度
modelShader.setFloat("specularStrength", 0.7f);     // 强反光

// 纹理设置（Model.h）
glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_LOD_BIAS, -1.0f);  // 最清晰
```

### A.2 性能优化配置

```cpp
// main.cpp 配置
const unsigned int SCR_WIDTH = 1280;
const unsigned int SCR_HEIGHT = 720;

// GLFW初始化
glfwWindowHint(GLFW_SAMPLES, 2);  // 2x MSAA

// 模型变换
modelMatrix = glm::scale(modelMatrix, glm::vec3(0.2f, 0.2f, 0.2f));  // 较小模型

// 材质属性
modelShader.setFloat("materialShininess", 32.0f);  // 低光泽度
modelShader.setFloat("specularStrength", 0.3f);    // 弱反光

// 减少光源数量（保留2-3个主光源）

// 纹理设置
glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_LOD_BIAS, 0.0f);  // 标准清晰度
```

### A.3 调试配置

```cpp
// 启用所有调试输出
std::cout << "Loading model: " << path << std::endl;
std::cout << "Loaded " << meshes.size() << " meshes" << std::endl;
std::cout << "Loaded " << textures_loaded.size() << " textures" << std::endl;

// 绘制线框模式
glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);  // 线框
glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);  // 实心（默认）

// 显示法线（需要额外shader）
// ...
```

---

## 总结

本文档涵盖了Fireworks_OpenGL项目中模型系统的所有关键方面：

1. **模型加载**：使用Assimp加载多种格式，智能纹理查找
2. **光照反射**：Blinn-Phong模型，可配置镜面反射参数
3. **光源管理**：动态点光源系统，支持永久和临时光源
4. **模型变换**：位置、旋转、缩放的完整控制
5. **清晰度优化**：纹理过滤、抗锯齿、法线平滑等技术

**关键文件：**
- `main.cpp` - 主渲染循环和场景设置
- `include/Model.h` - 模型加载和纹理管理
- `assets/shaders/model.fs` - 光照计算和材质渲染
- `include/PointLight.h` - 光源管理系统

**快速调整参考：**
- 模型位置：`main.cpp` 第189行
- 模型大小：`main.cpp` 第195行
- 光源配置：`main.cpp` 第110-132行
- 材质属性：`main.cpp` 第203-204行
- 纹理清晰度：`Model.h` 第245行

**下一步：**
- 实现烟花粒子系统
- 连接烟花爆炸与临时光源
- 添加更多视觉效果（拖尾、爆炸动画等）
